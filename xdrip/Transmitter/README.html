<p><style type="text/css">
  h2 { margin-left: 10px; }
  h3 { margin-left: 25px; }
  h4 { margin-left: 40px; }
</style></p>

<ul>
<li><a href="#summary">Summary</a></li>
<li><a href="#newtransmitters">Steps for adding new transmitter types</a>
<ul>
<li><a href="#protocolbluetoothtransmitterdelegate">conform to protocol BluetoothTransmitterDelegate</a>
<ul>
<li><a href="#centralManagerdidconnect">centralManagerDidConnect</a></li>
<li><a href="#centralmanagerdidfailtoconnect">centralManagerDidFailToConnect</a></li>
<li><a href="#centralmanagerdiddisconnectperipheral">centralManagerDidDisconnectPeripheral</a></li>
<li><a href="#centralManagerDidUpdateState">centralManagerDidUpdateState</a></li>
<li><a href="#peripheraldidupdatenotificationstatefor">peripheralDidUpdateNotificationStateFor</a></li>
<li><a href="#peripheraldidupatevaluefor">peripheralDidUpdateValueFor</a></li>
</ul></li>
<li><a href="#protocolCGMTransmitter">conform to protocol CGMTransmitter</a>
<ul>
<li><a href="#canDetectNewSensor">canDetectNewSensor</a></li>
<li><a href="#address">address</a></li>
<li><a href="#name">name</a></li>
<li><a href="#startScanning">startScanning</a></li>
</ul></li>
<li><a href="#extendclassbuetoothtransmitter">extend class BluetoothTransmitter</a>
<ul>
<li><a href="#initializebluetoothtransmitter">initialize the super class BluetoothTransmitter</a>
<ul>
<li><a href="#deviceaddressname">BluetoothTransmitter.DeviceAddressAndName</a></li>
<li><a href="#cbuuidadvertisement">CBUUID_Advertisement</a></li>
<li><a href="#cbuuidservice">CBUUID_Service</a></li>
<li><a href="#cbuuidreceivecharacteristic">CBUUID_ReceiveCharacteristic</a></li>
<li><a href="#cbuuidwritecharacteristic">CBUUID_WriteCharacteristic</a></li>
</ul></li>
</ul></li>
<li><a href="#protocolcgmtransmitterdelegate">add a property of type CGMTransmitterDelegate</a>
<ul>
<li><a href="#cgmTransmitterDidConnect">cgmTransmitterDidConnect</a></li>
<li><a href="#cgmTransmitterDidDisconnect">cgmTransmitterDidDisconnect</a></li>
<li><a href="#didUpdateBluetoothState">didUpdateBluetoothState</a></li>
<li><a href="#newSensorDetected">newSensorDetected</a></li>
<li><a href="#sensorNotDetected">sensorNotDetected</a></li>
<li><a href="#cgmTransmitterInfoReceived">cgmTransmitterInfoReceived</a></li>
<li><a href="#transmitterNeedsPairing">transmitterNeedsPairing</a></li>
</ul></li>
<li><a href="#implementtheprotocol">Implement the specific protocol</a>
<ul>
<li><a href="#functionsandpropertiesavailableintransmitterclasses">Functions and properties available in transmitter classes</a>
<ul>
<li><a href="#functionsinbluetoothtransmitterclasses">Functions in BluetoothTransmitter classes</a>
<ul>
<li><a href="#disconnect">disconnect</a></li>
<li><a href="#startScanning">startScanning</a></li>
<li><a href="#writeDataToPeripheral">writeDataToPeripheral(data:Data, type:CBCharacteristicWriteType) -> Bool</a></li>
<li><a href="#writeDataToPeripheral">writeDataToPeripheral(data:Data, characteristicToWriteTo:CBCharacteristic, type:CBCharacteristicWriteType) -> Bool</a></li>
<li><a href="#setNotifyValue">setNotifyValue</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#availablecgmtransmitterclasses">Available CGM transmitter classes</a>
<ul>
<li><a href="#MiaoMiao">MiaoMiao</a></li>
<li><a href="#xDripG4">xDripG4</a></li>
<li><a href="#DexcomG5">Dexcom G5</a></li>
</ul></li>
<li><a href="#useatransmitterclass">Use a transmitter class</a></li>
</ul>

<h1><a name="summary"></a>Summary</h1>

<p>BluetoothTransmitter.swift defines the class <strong>BluetoothTransmitter</strong>, which implements the bluetooth protocol applicable to any 
type of peripheral and that works with only a receive and a transmit characteristic. 
The class handles the scanning, connect, services discovery, characteristics discover, subscribing to characteristic,
connect and reconnect, connect after app launch 
(app needs to connect at least once, then it will remember the address and reconnect automatically at next launch)</p>

<p>If necessary, each of the functions in the protocols CBCentralManagerDelegate and CBPeripheralDelegatecan be overriden by the inheriting class.</p>

<p>The protocol <strong>BluetoothTransmitterDelegate</strong> defines functions that allow to pass bluetooth activity information from the 
BluetoothTransmitter class to a specific transmitter class. Example when a disconnect occurs, the BlueToothTransmitter class 
handles the reconnect but the delegate class can for instance show the connection status to the user. It will be informed about
the connection status via the function centralManagerDidConnect in the BluetoothTransmitterDelegate.</p>

<p>The <strong>CGMTransmitter</strong> protocol defines functions that CGM transmitter classes need to implement.</p>

<p>The CGM transmitter communicates back to the caller via the <strong>CGMTransmitterDelegate</strong> protocol.<br> 
Needs to be conformed to, for instance by a view controller, or manager, .. whatever<br>
This protocol allows passing information like new readings, sensor detected, and also connect/disconnect, bluetooth status change<br></p>

<p>Following specific transmitter classes exist:<br></p>

<ul>
<li><p><strong>CGMMiaoMiaoTransmitter</strong><br></p></li>
<li><p><strong>CGMG4xDripTransmitter</strong><br></p></li>
<li><p><strong>CGMG5Transmitter</strong><br></p></li>
</ul>

<h1><a name="newtransmitters"></a>Steps to adding new (CGM) transmitter types</h1>

<p>Every new type of bluetoothtransmitter needs to</p>

<ul>
<li>extend BluetoothTransmitter</li>
<li>conform to the protocol BluetoothTransmitterDelegate.</li>
</ul>

<p>If it's a CGM transmitter (it could also be a bloodglucose meter that transmits data over bluetooth)</p>

<ul>
<li>conform to the protocol CGMTransmitter</li>
</ul>

<h2><a name="protocolbluetoothtransmitterdelegate"></a>conform to protocol BluetoothTransmitterDelegate</h2>

<p>The protocol is used to pass back information from the BluetoothTransmitter class to the specific Transmitter class.</p>

<p>The functions that need to be implemented:</p>

<h3><a name="centralManagerdidconnect"><font color="purple">func</font> centralManagerDidConnect()</h3>

<p>Called when device disconnects. Can be used to pass information to the user. The new transmitter class can use the protocol CGMTransmitterDelegate 
to pass back this information to a controlling class</p>

<h3><a name="centralmanagerdidfailtoconnect"></a><font color="purple">func</font> centralManagerDidFailToConnect(error: Error?)</h3>

<p>Called when device fails to connect. Probably not useful, but it's there</p>

<h3><a name="centralmanagerdiddisconnectperipheral"></a><font color="purple">func</font> centralManagerDidDisconnectPeripheral(error: Error?)</h3>

<p>Called when device disconnects. Can be used to pass information to the user. The transmitter class can use the protocol CGMTransmitterDelegate 
to pass back this information to a controlling class</p>

<h3><a name="centralManagerDidUpdateState"></a><font color="purple">func</font> centralManagerDidUpdateState(state: <font color="purple">CBManagerState</font>)</h3>

<p>Called when bluetooth state changes, ie when user switches on or off bluetooth. This function also gets called immediately 
after startup of the application.<br>
The transmitter class can use the protocol CGMTransmitterDelegate to pass back this information to a controlling class<br>
It can be used by the controlling class to start scanning.</p>

<h3><a name="peripheraldidupdatenotificationstatefor"></a><font color="purple">func</font> peripheralDidUpdateNotificationStateFor(characteristic: CBCharacteristic, error: Error?)</h3>

<p>is called when BluetoothTranmsitter class function 
 peripheral(_ peripheral: CBPeripheral, didUpdateNotificationStateFor characteristic: CBCharacteristic, error: Error?) is called<br>
For instance in the MiaoMiao transmitter class, the implementation will call start reading command.<br>
For other types of transmitters there may be nothing to do.<br></p>

<h3><a name="peripheraldidupatevaluefor"></a><font color="purple">func</font> peripheralDidUpdateValueFor(characteristic: CBCharacteristic, error: Error?)</h3>

<p>This will be the most important function, because it contains the data that needs to be processed by the specific transmitter class.</p>

<h2><a name="protocolCGMTransmitter"></a>conform to protocol CGMTransmitter</h2>

<h3><a name="canDetectNewSensorprotocol"></a>canDetectNewSensor</h3>

<p>can the cgm transmitter detect that a new sensor is placed ? Will return true only for Libre type of transmitters, eg MiaoMiao<br>
If it returns true the the transmitter should also use newSensorDetected</p>

<h3><a name="address"></a>address</h3>

<p>This function is already implemented in the parent class BluetoothTransmitter, there's no need to implement it.</p>

<h3><a name="name"></a>name</h3>

<p>This function is already implemented in the parent class BluetoothTransmitter, there's no need to implement it.</p>

<h3><a name="startScanning"></a>startScanning</h3>

<p>This function is already implemented in the parent class BluetoothTransmitter, there's no need to implement it.</p>

<h2><a name="extendclassbuetoothtransmitter"></a>extend class BluetoothTransmitter</h2>

<p>A new transmitter class needs to extend BluetoothTransmitter and</p>

<h3><a name="initializebluetoothtransmitter"></a>initialize the super class BluetoothTransmitter</h3>

<p>the signature of the initializer of the super class BluetoothTransmitter is<br></p>

<p><font color="purple">init</font>(addressAndName:<font color="#516374">BluetoothTransmitter.DeviceAddressAndName</font>, 
CBUUID_Advertisement:<font color="purple">String</font>, 
CBUUID_Service:<font color="purple">String</font>, 
CBUUID_ReceiveCharacteristic:<font color="purple">String</font>, 
CBUUID_WriteCharacteristic:<font color="purple">String</font>) {</p>

<h4><a name="deviceaddressname"></a>BluetoothTransmitter.DeviceAddressAndName</h4>

<p>If the app never connected to the device, then we don't know it's name and address as the device itself is going to send.<br> 
Possibly we have an expected device name. Not all devices have a predefined device name (example xdrip/xbridge have different names).<br>
Usually, if there's no expected device name, there will be a CBUUID_Advertisement<br></p>

<p>If the app connected before, then we have the address (should be stored in the settings or somewhere) which needs to be set during
initialization</p>

<p>DeviceAddressAndName is an enum with two cases :</p>

<ul>
<li><p>alreadyConnectedBefore in which case we add the address and name as stored in the settings or database.
The app will only connected to a device if it has the same address.</p></li>
<li><p>notYetConnected if we have an expected name, then it's added, if we don't then we pass nil<br>
The app will connected to a device if the name starts with the expected name, or in case the expected name is nil, it will connect</p></li>
</ul>

<h4><a name="cbuuidadvertisement"></a>CBUUID_Advertisement</h4>

<p>optional<br>
If not nil then the app will scan for devices that advertise with this specific UUID.
The advantage of scanning with advertisement UUID is that the app can also scan while in the background.</p>

<h4><a name="cbuuidservice"></a>CBUUID_Service</h4>

<p>The service UUID</p>

<h4><a name="cbuuidreceivecharacteristic"></a>CBUUID_ReceiveCharacteristic</h4>

<p>receive characteristic UUID, the BlueToothTransmitter class will take care of subscribing to it</p>

<h4><a name="cbuuidwritecharacteristic"></a>CBUUID_WriteCharacteristic</h4>

<p>write characteristic UUID</p>

<h2><a name="protocolcgmtransmitterdelegate"></a>add a property of type CGMTransmitterDelegate</h2>

<p>The new transmitter class needs to store a property of type CGMTransmitterDelegate<br>
This is used to pass back information to the controller<br></p>

<p>Define it as a weak var</p>

<p>Functions in CGMTransmitterDelegate:</p>

<h3><a name="cgmTransmitterDidConnect"></a>cgmTransmitterDidConnect</h3>

<p>When the transmitter is connected<br>
This will typically be called in centralManagerDidConnect, however it could be that the class decides to call this at a
later stage, for example when subscribing to receive characteristic is done.</p>

<h3><a name="cgmTransmitterDidDisconnect"></a>cgmTransmitterDidDisconnect</h3>

<p>When the transmitter is disconnected<br>
This will typically be called in centralManagerDidDisConnect</p>

<h3><a name="didUpdateBluetoothState"></a>didUpdateBluetoothState</h3>

<p>When the bluetooth status changes<br>
This will typically be called in centralManagerDidUpdateState</p>

<h3><a name="newSensorDetected"></a>newSensorDetected</h3>

<p>When a new sensor is detected, only applicable to transmitters that have this functionality</p>

<h3><a name="sensorNotDetected"></a>sensorNotDetected</h3>

<p>When a sensor is not detected, only applicable to transmitters that have this functionality</p>

<h3><a name="cgmTransmitterInfoReceived"></a>cgmTransmitterInfoReceived</h3>

<p>This is the most important function, it passes new readings to the delegate</p>

<p>also battery info, sensor state, firmware &amp; hardware info if applicable</p>

<h3><a name="transmitterNeedsPairing"></a>transmitterNeedsPairing</h3>

<p>The transmitter needs pairing, app should give warning to user to keep the app in the foreground</p>

<h2><a name="implementtheprotocol"></a>Implement the transmitter protocol</h2>

<p>The specific protocol needs to be implemented.</p>

<p>See as example already existing cgm transmitter classes.</p>

<p>All functions in the parent class can be overriden.</p>

<p>Following additional functions can be used :</p>

<h3><a name="functionsandpropertiesavailableintransmitterclasses"></a>Functions and properties available in transmitter classes</h3>

<h4><a name="functionsinbluetoothtransmitterclasses"></a>Functions in BluetoothTransmitter classes</h4>

<p>These functions should only be used by classes that extend the BluetoothTransmitter class.</p>

<h5><a name="disconnect"></a>disconnect</h5>

<p>will call centralManager.cancelPeripheralConnection</p>

<h5><a name="startScanning"></a>startScanning</h5>

<p>Will scan for the device.<br>
This should only be used the first time the app connects to a specific device and should not be done for transmittertypes that 
start scanning at initialization<br></p>

<h5><a name="writeDataToPeripheral"></a>writeDataToPeripheral(data:Data, type:CBCharacteristicWriteType)  -> Bool</h5>

<p>calls peripheral.writeValue for characteristic CBUUID_WriteCharacteristic<br></p>

<p>Make sure that the parent class has initialized the parameter writeCharacteristic.<br>
This may not be the case of the deriving transmitter class has overriden the method func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?)</p>

<h5><a name="writeDataToPeripheral"></a>writeDataToPeripheral(data:Data, characteristicToWriteTo:CBCharacteristic, type:CBCharacteristicWriteType)  -> Bool</h5>

<p>calls peripheral.writeValue for characteristic that is given as argment : characteristicToWriteTo</p>

<h5><a name="setNotifyValuefunc"></a>setNotifyValue(_ enabled: Bool, for characteristic: CBCharacteristic)</h5>

<p>calls setNotifyValue for characteristic with value enabled</p>

<h1><a name="availablecgmtransmitterclasses"></a>Available CGM transmitter classes</h1>

<h2><a name="MiaoMiao"></a>MiaoMiao</h2>

<p>MiaoMiao transmitter is fully implemented<br>
class CGMMiaoMiaoTransmitter</p>

<h2><a name="xDripG4"></a>xDripG4</h2>

<p>xDripG4 transmitter is fully implemented<br>
class CGMG4xDripTransmitter</p>

<h2><a name="DexcomG5"></a>Dexcom G5</h2>

<p>Dexcom G5 is implemented:</p>

<ul>
<li>no backfilling</li>
<li>not yet tested with transmitter on sensor</li>
</ul>

<h1><a name="useatransmitterclass"></a>Use a Transmitter class</h1>

<ul>
<li><p>conform to protocol CGMTransmitterDelegate</p></li>
<li><p>implement the functions in CGMTransmitterDelegate</p>

<ul>
<li><p>cgmTransmitterDidConnect :  Called when the transmitter has connected. The function gives the name and address.<br>
Store the address in permanent storage, next time the transmitter is initialized, give it the address value<br>
It will ease the initial connect</p></li>
<li><p>cgmTransmitterDidDisconnect : To give info to the user that the transmitter has disconnected, if needed to give that info.</p></li>
<li><p>deviceDidUpdateBluetoothState : Gives the status of Bluetooth (on/off ..)<br>
Specifically useful if first scan still needs to occur. May not be useful at all.</p></li>
<li><p>newSensorDetected : Typically for MiaoMiao, can be used to automatically start the sensor, no need to ask the user to do this.</p></li>
<li><p>sensorNotDetected : Typically for MiaoMiao</p></li>
<li><p>func cgmTransmitterInfoReceived(glucoseData:inout [RawGlucoseData], transmitterBatteryInfo:TransmitterBatteryInfo?, sensorState:SensorState?, sensorTimeInMinutes:Int?, firmware:String?, hardware:String?)
Can contain lots of data, like new readings (raw readings), ...</p></li>
<li><p>cgmTransmitterNeedsPairing : Warn the user that app should stay in foreground</p></li>
</ul></li>
<li><p>Define a variable of type CGMTransmitter and initialize it with any of the transmitter classes</p>

<ul>
<li>In intializer, give it the address if known, or nil if not. If needed also transmitter id and pass it the CGMTransmitterDelegate</li>
</ul></li>
</ul>
